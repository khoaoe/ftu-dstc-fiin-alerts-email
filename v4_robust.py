# -*- coding: utf-8 -*-
"""problem2_FinLab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T4jgiLp0msmvNWZx07Utu0VvfjW56MAY

# Hướng dẫn Vận hành và Backtest Chiến lược V4-Robust

**Tác giả:** FinLab

### Giới thiệu
Tài liệu này cung cấp một pipeline hoàn chỉnh để thực thi và đánh giá **Chiến lược Giao dịch V4-Robust**. Đây là một chiến lược "Event-driven", được thiết kế để hoạt động linh hoạt, quản trị rủi ro chủ động và đã được mô phỏng với các điều kiện giao dịch thực tế.

**Các bước chính trong Notebook:**
1.  **Cài đặt & Nạp thư viện:** Chuẩn bị môi trường cần thiết.
2.  **Định nghĩa các Hàm Cốt lõi:** Nơi chứa cấu trúc của hệ thống, bao gồm logic sàng lọc và engine backtest.
3.  **Tải Dữ liệu:** Nạp bộ dữ liệu đã được làm giàu.
4.  **Thiết lập & Thực thi:** Chạy backtest với các tham số tùy chỉnh.
5.  **Phân tích Kết quả:** Trực quan hóa và đánh giá sâu về hiệu suất.
"""

# ===================================================================
# 1. CÀI ĐẶT & NẠP CÁC THƯ VIỆN CẦN THIẾT
# ===================================================================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings
from pypfopt import expected_returns, risk_models
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt.exceptions import OptimizationError
import time
from collections import deque, defaultdict
import os

# Tắt các cảnh báo không cần thiết để output gọn gàng
warnings.filterwarnings('ignore', category=FutureWarning)
warnings.filterwarnings('ignore', category=UserWarning)

print("Các thư viện đã được nạp thành công.")

"""## 2. Định nghĩa các Hàm Cốt lõi
Phần này chứa toàn bộ logic của hệ thống, bao gồm hàm sàng lọc và engine backtest V4-Robust.
"""

# ===================================================================
# 2. CÁC HÀM CỐT LÕI CỦA HỆ THỐNG
# ===================================================================

def apply_baseline_screener(df_day: pd.DataFrame, min_volume_ma20=100000) -> list:
    if df_day.empty:
        return []
    df_day = df_day[df_day['volume_ma20'] > min_volume_ma20]
    df_filtered = df_day[df_day['market_close'] > df_day['market_MA200']]
    df_filtered = df_filtered[df_filtered['volume'] > 200000]
    df_filtered = df_filtered[df_filtered['close'] > df_filtered['sma_200']]
    df_filtered = df_filtered[
        (df_filtered['close'] > df_filtered['sma_50']) &
        (df_filtered['rsi_14'] > 55) & (df_filtered['rsi_14'] < 75)
    ]
    df_filtered = df_filtered.dropna(subset=['volume_spike'])
    df_filtered = df_filtered[df_filtered['volume_spike'] > 0.5]
    return df_filtered['ticker'].unique().tolist()


def backtest_engine_krx(
    data,
    screener_func,
    start_date_str,
    end_date_str,
    initial_capital,
    base_capital,
    commission_buy=0.00227,
    commission_sell_base=0.00227,
    tax_sell=0.001,
    trade_limit_pct=0.02,
    max_open_positions=10,
    min_volume_ma20=100000,
    lot_size=100
):
    start_time = time.time()

    # --- PHẦN CHUẨN BỊ ---
    backtest_data = data.copy()
    if 'volume_ma20' not in backtest_data.columns:
        backtest_data['volume_ma20'] = backtest_data.groupby('ticker')['volume'].transform(lambda x: x.rolling(20).mean())
    if 'highest_in_5d' not in backtest_data.columns:
        backtest_data['highest_in_5d'] = backtest_data.groupby('ticker')['high'].transform(lambda x: x.rolling(5).max().shift(1))

    backtest_data = backtest_data[(backtest_data.index >= start_date_str) & (backtest_data.index <= end_date_str)]

    # --- PIVOT DATA ĐỂ TĂNG TỐC ---
    pivoted_data = backtest_data.pivot_table(index='time', columns='ticker', values=['close', 'open', 'high', 'low', 'volume_spike', 'boll_width', 'volume_ma20'])
    # --- PIVOT DATA ĐỂ TĂNG TỐC---
    pivoted_close = backtest_data.pivot_table(index='time', columns='ticker', values='close')
    pivoted_open = backtest_data.pivot_table(index='time', columns='ticker', values='open')
    pivoted_high = backtest_data.pivot_table(index='time', columns='ticker', values='high')
    pivoted_low = backtest_data.pivot_table(index='time', columns='ticker', values='low')
    pivoted_boll_width = backtest_data.pivot_table(index='time', columns='ticker', values='boll_width')
    pivoted_volume_ma20 = backtest_data.pivot_table(index='time', columns='ticker', values='volume_ma20')
    pivoted_volume_spike = backtest_data.pivot_table(index='time', columns='ticker', values='volume_spike')

    # --- VỐN & LỊCH SỬ ---
    working_capital = base_capital
    profit_vault = initial_capital - base_capital
    portfolio_history = []
    current_portfolio = {}
    watchlist = []

    pending_funds = deque()
    trades = []

    all_dates = sorted(backtest_data.index.unique())

    for i, date in enumerate(all_dates):
        # Giải phóng vốn T+2
        settled_cash = 0
        while pending_funds and pending_funds[0][0] <= date:
            settled_cash += pending_funds.popleft()[1]
        working_capital += settled_cash

        # Quản lý vị thế
        for ticker, pos in list(current_portfolio.items()):
            high, low, close = pivoted_high.at[date, ticker], pivoted_low.at[date, ticker], pivoted_close.at[date, ticker]
            if not pd.isna(high):
                if high >= pos['tp'] or low <= pos['sl'] or date >= pos['end_date']:
                    net_proceeds = (close * pos['shares']) * (1 - commission_sell_base - tax_sell)
                    settlement_date = all_dates[min(i + 2, len(all_dates) - 1)]
                    pending_funds.append((settlement_date, net_proceeds))
                    trades.append({'profit': net_proceeds - (pos['shares'] * pos['entry_price'])})
                    del current_portfolio[ticker]

        # Logic Hàng tuần
        if date.weekday() == 0:
            today_data_unfiltered = backtest_data[backtest_data.index == date]
            watchlist = screener_func(today_data_unfiltered, min_volume_ma20)
            if working_capital > base_capital:
                profit_vault += working_capital - base_capital
                working_capital = base_capital

        # Tìm kiếm mua
        if watchlist and len(current_portfolio) < max_open_positions:
            today_data = backtest_data[(backtest_data.index == date) & backtest_data['ticker'].isin(watchlist)]
            if not today_data.empty:
                today_data['is_breakout'] = today_data['close'] > today_data['highest_in_5d']
                today_data['is_volume_confirmed'] = today_data['volume_spike'] > 0.5
                candidates = today_data[today_data['is_breakout'] & today_data['is_volume_confirmed']]

                for _, row in candidates.iterrows():
                    ticker = row['ticker']
                    if ticker in current_portfolio: continue
                    entry_price = row['open']
                    if entry_price <= 0: continue

                    slots_to_fill = max_open_positions - len(current_portfolio)
                    investment_per_stock = working_capital / slots_to_fill
                    intended_shares = (investment_per_stock / (1 + commission_buy)) / entry_price
                    max_shares_by_volume = row['volume_ma20'] * trade_limit_pct if not pd.isna(row['volume_ma20']) else float('inf')
                    actual_shares_to_buy = min(intended_shares, max_shares_by_volume)
                    actual_shares_to_buy = (actual_shares_to_buy // lot_size) * lot_size  # Lô chẵn

                    if actual_shares_to_buy > 0:
                        actual_cost = actual_shares_to_buy * entry_price * (1 + commission_buy)
                        if actual_cost > working_capital: continue
                        working_capital -= actual_cost
                        current_portfolio[ticker] = {
                            'shares': actual_shares_to_buy, 'entry_price': entry_price,
                            'tp': entry_price + (2 * row['boll_width']), 'sl': entry_price - (1 * row['boll_width']),
                            'end_date': date + pd.Timedelta(days=42)
                        }
                        if len(current_portfolio) >= max_open_positions:
                            break

        # --- CẬP NHẬT HISTORY---
        # 1. Tính giá trị cổ phiếu đang nắm giữ
        stocks_value = 0
        if current_portfolio:
            for ticker, pos in current_portfolio.items():
                current_price = pivoted_close.at[date, ticker]
                # Nếu không có giá hôm nay (ví dụ nghỉ lễ), tạm dùng giá vào lệnh
                price_to_use = current_price if not pd.isna(current_price) else pos['entry_price']
                stocks_value += pos['shares'] * price_to_use

        # 2. Tính giá trị tiền mặt đang chờ về (Quan trọng nhất)
        cash_in_transit = sum(fund[1] for fund in pending_funds)

        # 3. Tổng giá trị thực của danh mục
        total_value = working_capital + stocks_value + cash_in_transit + profit_vault
        portfolio_history.append({'date': date, 'Portfolio Value': total_value})

    df_history = pd.DataFrame(portfolio_history).set_index('date')

    # Tính metrics
    total_return = (df_history.iloc[-1]['Portfolio Value'] / df_history.iloc[0]['Portfolio Value'] - 1) if not df_history.empty else 0
    num_trades = len(trades)
    win_rate = len([t for t in trades if t['profit'] > 0]) / num_trades if num_trades > 0 else 0
    years = (df_history.index[-1] - df_history.index[0]).days / 365.25
    cagr = ((df_history.iloc[-1]['Portfolio Value'] / df_history.iloc[0]['Portfolio Value']) ** (1 / years) - 1) if years > 0 else 0
    returns = df_history['Portfolio Value'].pct_change().dropna()
    sharpe_ratio = (returns.mean() * 252) / (returns.std() * np.sqrt(252)) if returns.std() != 0 else 0
    max_drawdown = ((df_history['Portfolio Value'].cummax() - df_history['Portfolio Value']) / df_history['Portfolio Value'].cummax()).max()

    print(f"Backtest time: {time.time() - start_time:.2f} seconds")
    print(f"Metrics: Total Return={total_return:.2%}, CAGR={cagr:.2%}, Sharpe Ratio={sharpe_ratio:.2f}, "
          f"Max Drawdown={max_drawdown:.2%}, Num Trades={num_trades}, Win Rate={win_rate:.2%}")

    return df_history, {
        'Total Return': total_return, 'CAGR': cagr, 'Sharpe Ratio': sharpe_ratio,
        'Max Drawdown': max_drawdown, 'Num Trades': num_trades, 'Win Rate': win_rate
    }

# Hàm phụ trợ để tính benchmark và metrics
def calculate_benchmark(data, start_date_str, end_date_str, initial_capital):
    vni_data = data[['market_close']].dropna()
    vni_data = vni_data[~vni_data.index.duplicated(keep='first')]
    vni_data = vni_data[(vni_data.index >= start_date_str) & (vni_data.index <= end_date_str)]
    start_price = vni_data['market_close'].iloc[0]
    return (vni_data['market_close'] / start_price) * initial_capital

def calculate_metrics(performance_series):
    total_return = (performance_series.iloc[-1] / performance_series.iloc[0]) - 1
    daily_returns = performance_series.pct_change().dropna()
    sharpe_ratio = (daily_returns.mean() / daily_returns.std()) * np.sqrt(252) if daily_returns.std() != 0 else 0
    cumulative_max = performance_series.cummax()
    drawdown = (performance_series - cumulative_max) / cumulative_max
    max_drawdown = drawdown.min()
    return {
        "Total Return": f"{total_return:.2%}",
        "Sharpe Ratio (Annualized)": f"{sharpe_ratio:.2f}",
        "Max Drawdown": f"{max_drawdown:.2%}"
    }

print("Đã định nghĩa xong các hàm cốt lõi.")

"""## 3. Tải Dữ liệu
Chúng ta sẽ nạp bộ dữ liệu `data-v2.parquet` đã được làm giàu. File này chứa đầy đủ dữ liệu giá và các chỉ báo kỹ thuật cần thiết.
"""

# ===================================================================
# 3. TẢI DỮ LIỆU
# ===================================================================
DATA_FILE_PATH = r"E:\Document\Tao\Study\Data Science Talent Competition 2025\problem2\solution\data-v2.parquet"

if not os.path.exists(DATA_FILE_PATH):
    print(f"Lỗi: Không tìm thấy file dữ liệu '{DATA_FILE_PATH}'.")
    print("Vui lòng đảm bảo file dữ liệu nằm trong cùng thư mục với Notebook này.")
else:
    df = pd.read_parquet(DATA_FILE_PATH)
    if 'time' in df.columns:
        df['time'] = pd.to_datetime(df['time'])
        df = df.set_index('time').sort_index()

    print(f"Tải dữ liệu thành công. Dữ liệu kéo dài từ {df.index.min().date()} đến {df.index.max().date()}.")
    print(f"Tổng số bản ghi: {len(df):,}")

"""## 4. Thiết lập & Thực thi Backtest
Đây là "bảng điều khiển" chính. Người dùng có thể tùy chỉnh các tham số như khoảng thời gian backtest, vốn ban đầu, v.v.
Sau khi thiết lập, chúng ta sẽ chạy engine backtest.
"""

# ===================================================================
# 4. THIẾT LẬP THAM SỐ VÀ THỰC THI
# ===================================================================

# --- Bảng điều khiển ---
TEST_START_DATE = '2020-01-01'
TEST_END_DATE = '2025-08-20'
INITIAL_CAPITAL = 1_000_000_000 # 1 Tỷ VND
BASE_CAPITAL_TO_TRADE = 1_000_000_000 # Giao dịch trên vốn cố định 1 tỷ để tránh việc lấy lãi làm vốn mà lãi quá nhiều khiến backtest không chính xác
# --------------------

print(f"--- Bắt đầu chạy Backtest từ {TEST_START_DATE} đến {TEST_END_DATE} ---")

# 1. Chạy Benchmark
print("Đang tính toán Benchmark: VN-Index...")
benchmark_performance = calculate_benchmark(df, TEST_START_DATE, TEST_END_DATE, INITIAL_CAPITAL)

# 2. Chạy Chiến lược V4-Robust
print("Đang chạy Backtest V4-Robust...")
performance_v4, snapshots_v4 = backtest_engine_krx(
    data=df,
    screener_func=apply_baseline_screener,
    start_date_str=TEST_START_DATE,
    end_date_str=TEST_END_DATE,
    initial_capital=INITIAL_CAPITAL,
    base_capital=BASE_CAPITAL_TO_TRADE
)
print("--- Hoàn thành Backtest. ---")

"""### Cell 9: (Markdown)
```markdown
## 5. Phân tích Kết quả
Sau khi chạy backtest, chúng ta sẽ phân tích và trực quan hóa kết quả để đánh giá hiệu suất.
"""

# ===================================================================
# 5.1 Bảng so sánh Hiệu suất Tổng thể
# ===================================================================
metrics_v4 = calculate_metrics(performance_v4['Portfolio Value'])
metrics_benchmark = calculate_metrics(benchmark_performance)

print("\n--- BẢNG SO SÁNH HIỆU SUẤT CUỐI CÙNG ---")
print(f"{'Chiến lược':<40} | {'Tổng Lợi nhuận':>15} | {'Sharpe Ratio':>15} | {'Max Drawdown':>15}")
print("-" * 90)
print(f"{'Benchmark: VN-Index':<40} | {metrics_benchmark['Total Return']:>15} | {metrics_benchmark['Sharpe Ratio (Annualized)']:>15} | {metrics_benchmark['Max Drawdown']:>15}")
print(f"{'Chiến lược V4-Robust':<40} | {metrics_v4['Total Return']:>15} | {metrics_v4['Sharpe Ratio (Annualized)']:>15} | {metrics_v4['Max Drawdown']:>15}")
print("-" * 90)

# ===================================================================
# 5.2 Trực quan hóa Đường cong Vốn
# ===================================================================
plt.style.use('seaborn-v0_8-whitegrid')
fig, ax = plt.subplots(figsize=(20, 10))

# Vẽ
ax.plot(benchmark_performance.index, benchmark_performance,
        label=f"Benchmark: VN-Index ({metrics_benchmark['Total Return']})",
        linestyle=':', color='black', alpha=0.7)

ax.plot(performance_v4.index, performance_v4['Portfolio Value'],
        label=f"Chiến lược V4-Robust ({metrics_v4['Total Return']})",
        linewidth=3.5, color='peachpuff', alpha=0.9)

# Định dạng
ax.set_title(f"So sánh Hiệu suất Cuối cùng các Chiến lược ({TEST_START_DATE} - {TEST_END_DATE})", fontsize=20)
ax.set_xlabel("Ngày", fontsize=16); ax.set_ylabel("Giá trị Danh mục (VND - Thang đo Log)", fontsize=16)
ax.set_yscale('log')
ax.grid(True, which="both", ls="--", linewidth=0.5)
ax.legend(fontsize=14, loc='upper left')
plt.xticks(fontsize=12); plt.yticks(fontsize=12)

plt.show()